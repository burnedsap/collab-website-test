name: Sync Notion Content

on:
  schedule:
    # Run daily at 6 AM UTC (adjust timezone as needed)
    - cron: '0 6 * * *'
  
  # Allow manual triggering for testing
  workflow_dispatch:

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Create content directory
      run: mkdir -p content
      
    - name: Fetch and process Notion content
      env:
        NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
        NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
      run: |
        cat > fetch-notion.js << 'EOF'
        const https = require('https');
        const fs = require('fs');

        const NOTION_TOKEN = process.env.NOTION_TOKEN;
        const PAGE_ID = process.env.NOTION_PAGE_ID;

        if (!NOTION_TOKEN || !PAGE_ID) {
          console.error('Missing NOTION_TOKEN or NOTION_PAGE_ID environment variables');
          process.exit(1);
        }

        function fetchNotionBlocks() {
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.notion.com',
              path: `/v1/blocks/${PAGE_ID}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${NOTION_TOKEN}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            const req = https.request(options, (res) => {
              let data = '';
              
              res.on('data', (chunk) => {
                data += chunk;
              });
              
              res.on('end', () => {
                if (res.statusCode === 200) {
                  try {
                    const jsonData = JSON.parse(data);
                    resolve(jsonData);
                  } catch (error) {
                    reject(new Error('Failed to parse JSON response'));
                  }
                } else {
                  reject(new Error(`HTTP error! status: ${res.statusCode}, body: ${data}`));
                }
              });
            });

            req.on('error', (error) => {
              reject(error);
            });

            req.end();
          });
        }

        function convertRichText(richTextArray) {
          if (!richTextArray || !Array.isArray(richTextArray)) {
            return '';
          }

          return richTextArray.map(text => {
            let html = text.plain_text || '';
            
            if (text.annotations) {
              if (text.annotations.bold) html = `<strong>${html}</strong>`;
              if (text.annotations.italic) html = `<em>${html}</em>`;
              if (text.annotations.strikethrough) html = `<s>${html}</s>`;
              if (text.annotations.underline) html = `<u>${html}</u>`;
              if (text.annotations.code) html = `<code>${html}</code>`;
            }
            
            if (text.href) {
              html = `<a href="${text.href}" target="_blank">${html}</a>`;
            }
            
            return html;
          }).join('');
        }

        function convertNotionBlockToHTML(block) {
          const type = block.type;
          const content = block[type];

          if (!content) {
            return '';
          }

          switch (type) {
            case 'paragraph':
              const paragraphText = convertRichText(content.rich_text);
              return paragraphText ? `<p>${paragraphText}</p>` : '';
            
            case 'heading_1':
              const h1Text = convertRichText(content.rich_text);
              return h1Text ? `<h1>${h1Text}</h1>` : '';
            
            case 'heading_2':
              const h2Text = convertRichText(content.rich_text);
              return h2Text ? `<h2>${h2Text}</h2>` : '';
            
            case 'heading_3':
              const h3Text = convertRichText(content.rich_text);
              return h3Text ? `<h3>${h3Text}</h3>` : '';
            
            case 'bulleted_list_item':
              const bulletText = convertRichText(content.rich_text);
              return bulletText ? `<li>${bulletText}</li>` : '';
            
            case 'numbered_list_item':
              const numberedText = convertRichText(content.rich_text);
              return numberedText ? `<li>${numberedText}</li>` : '';
            
            case 'quote':
              const quoteText = convertRichText(content.rich_text);
              return quoteText ? `<blockquote>${quoteText}</blockquote>` : '';
            
            case 'divider':
              return '<hr>';
              
            case 'callout':
              const calloutText = convertRichText(content.rich_text);
              return calloutText ? `<div class="callout">${calloutText}</div>` : '';
            
            default:
              const defaultText = convertRichText(content.rich_text || []);
              return defaultText ? `<p>${defaultText}</p>` : '';
          }
        }

        function groupListItems(htmlArray) {
          const result = [];
          let currentList = null;
          let currentListType = null;

          htmlArray.forEach(html => {
            if (html.startsWith('<li>')) {
              // Simple approach: treat all <li> as bulleted lists
              // You could enhance this by tracking the original block type
              if (currentListType !== 'ul') {
                if (currentList) {
                  result.push(`</${currentListType}>`);
                }
                currentListType = 'ul';
                result.push('<ul>');
              }
              result.push(html);
            } else {
              if (currentListType) {
                result.push(`</${currentListType}>`);
                currentListType = null;
              }
              if (html.trim()) {
                result.push(html);
              }
            }
          });

          // Close any remaining list
          if (currentListType) {
            result.push(`</${currentListType}>`);
          }

          return result;
        }

        async function main() {
          try {
            console.log('Fetching Notion content...');
            const data = await fetchNotionBlocks();
            
            console.log(`Fetched ${data.results.length} blocks`);
            
            // Convert blocks to HTML
            const htmlBlocks = data.results
              .map(block => convertNotionBlockToHTML(block))
              .filter(html => html.trim() !== '');
            
            // Group list items properly
            const groupedHtml = groupListItems(htmlBlocks);
            
            const content = groupedHtml.join('\n');
            
            // Create output object
            const output = {
              content: content,
              lastUpdated: new Date().toISOString(),
              blocksProcessed: data.results.length
            };
            
            // Write to file
            fs.writeFileSync('content/notion-content.json', JSON.stringify(output, null, 2));
            
            console.log('Content successfully written to content/notion-content.json');
            console.log(`Processed ${output.blocksProcessed} blocks`);
            
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          }
        }

        main();
        EOF
        
        node fetch-notion.js
        
    - name: Commit and push if content changed
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add content/notion-content.json
        
        # Only commit if there are changes
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update Notion content - $(date)"
          git push
        fi
